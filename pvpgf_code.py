# -*- coding: utf-8 -*-
"""PVPGF_Code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W43AvsA1lE_qZqO98DByY8YyzI7dBFav

# **PV Power Generation Forecasting Based on XGBoost and LSTM Models**
## *Cinthia Rodriguez, Jesús López, Sergio Cantillo and Yuri López*

###Contact:
> Cinthia Kathalina Rodríguez - cinthia.rodriguez@uao.edu.co

# Libraries
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.api as sm
from statsmodels.tsa.seasonal import seasonal_decompose, STL
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, mean_absolute_percentage_error
from sklearn.metrics import r2_score

from xgboost import XGBRegressor
import xgboost as xgb

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Dropout
from keras.callbacks import ModelCheckpoint, EarlyStopping, ReduceLROnPlateau, CSVLogger


from plotly.subplots import make_subplots
import plotly.graph_objects as go
import plotly.figure_factory as ff
import plotly.express as px

"""# Data Preprocessing

## Data Import
"""

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

#change your path
data = pd.read_excel('/content/drive/My Drive/GitHub/PVPGF/DatasetGeneracion3.xlsx',  index_col=0)

data.index = pd.to_datetime(data.index, format='%d/%m/%Y %H:%M').strftime('%Y-%m-%d %H:%M:%S')
data.index = pd.to_datetime(data.index)
print(type(data.index))

data.head(23000)

Datos = data.copy()
Datos.head()

Datos.info()

Datos.memory_usage().sum()

total = Datos.isnull().sum().sort_values(ascending=False)
percent_1 = Datos.isnull().sum()/Datos.isnull().count()*100
percent_2 = (round(percent_1, 1)).sort_values(ascending=False)
missing_data = pd.concat([total, percent_2], axis=1, keys=['Total', '%'])
missing_data.head(Datos.size)

Datos.describe().transpose()

Datos['Date'] = Datos.index
Datos['Year'] = Datos.index.year
Datos['Month'] = Datos.index.month
Datos['Day'] = Datos.index.day
Datos['Day number'] = Datos.index.day_of_week
Datos['Hour'] = Datos.index.hour

Datos.head(23000)

plt.figure(figsize=(6, 2))
plt.plot(Datos['Generacion_(kWh)'])
plt.plot(Datos['Generacion_(kWh)'], color='#EC7C30')

plt.xlabel('Time (hour)')
plt.ylabel('Generation (kWh)')
plt.gca().set_facecolor('white')
fecha_minima = pd.Timestamp('2018-05-01 06:00:00')
fecha_maxima = pd.Timestamp('2023-02-28 18:00:00')
plt.xlim(fecha_minima, fecha_maxima)
plt.xticks(rotation=15, ha="right")

plt.grid(True, color='lightgray')
plt.show()

"""## Data Imputation

For data imputation, three different forms of imputation were tested for performance, so first a section of the time series without information gaps was selected.
"""

DatosP = Datos.copy()
DatosP.head()

DatosPI = DatosP.loc['2022-02-21 06:00:00':'2023-02-28 18:00:00']
DatosPI.head(5000)

total = DatosPI.isna().sum().sort_values(ascending=False)
percent_1 = DatosPI.isna().sum()/DatosPI.isna().count()*100
percent_2 = (round(percent_1, 1)).sort_values(ascending=False)
missing_data = pd.concat([total, percent_2], axis=1, keys=['Total', '%'])
missing_data.head(DatosPI.size)

plt.figure(figsize=(10, 2.5))
plt.plot(DatosPI['Generacion_(kWh)'])
plt.plot(DatosPI['Generacion_(kWh)'], color='#EC7C30')

plt.xlabel('Dates')
plt.ylabel('Generation (kWh)')
plt.gca().set_facecolor('white')

plt.grid(True, color='lightgray')
plt.show()

"""Later, data was randomly selected."""

start_date = '2022-04-21 06:00:00'
random_data = DatosPI[DatosPI.index >= start_date].sample(n=485)  # Seleccionar 485 filas aleatorias

print(random_data)

"""Given the characteristics of the series, there are data with zero value. To identify the missing data and replace them during imputation, the value of the randomly selected data was changed to 600, a number outside the range of the data."""

DatosPI2 = DatosPI.copy()
DatosPI2.loc[random_data.index, 'Generacion_(kWh)'] = 600

plt.figure(figsize=(20, 2.5))
plt.plot(DatosPI2['Generacion_(kWh)'])
plt.plot(DatosPI2['Generacion_(kWh)'], color='#EC7C30')

plt.xlabel('Dates')
plt.ylabel('Generation (kWh)')
plt.gca().set_facecolor('white')

plt.grid(True, color='lightgray')
plt.show()

"""### Average with moving window"""

DatosPIP = DatosPI2.copy()

cont= 0
for i in range(0, len(DatosPIP.index)):

  if DatosPIP.iloc[i, 0] == 600:

    old_data = DatosPIP[DatosPIP["Date"].apply(lambda x: x.hour == DatosPIP['Hour'].iloc[i] and x < DatosPIP["Date"].iloc[i])]
    Prom = (old_data['Generacion_(kWh)'][-60:-30].mean())*0.7 + (old_data['Generacion_(kWh)'][-30:].mean())*0.3

    if Prom >= 200:

      Prom = Prom + abs(np.random.normal(loc=104.3, scale=83.52, size=1))*0.05

    DatosPIP['Generacion_(kWh)'].iloc[i] = Prom

DatosPIP.head()

# Plotting Generation
plt.figure(figsize=(10, 3))
plt.plot(DatosPI['Generacion_(kWh)'], color='darkblue')
plt.plot(DatosPIP['Generacion_(kWh)'], color='darkorange')

plt.xlabel('Dates')
plt.ylabel('Generation (kWh)')
plt.gca().set_facecolor('white')

plt.grid(True, color='lightgray')
plt.show()

total = DatosPIP.isna().sum().sort_values(ascending=False)
percent_1 = DatosPIP.isna().sum()/DatosPIP.isna().count()*100
percent_2 = (round(percent_1, 1)).sort_values(ascending=False)
missing_data = pd.concat([total, percent_2], axis=1, keys=['Total', '%'])
missing_data.head(DatosPIP.size)

"""RMSE calculation"""

MSE_I1 = mean_squared_error(DatosPI['Generacion_(kWh)'], DatosPIP['Generacion_(kWh)'])

RMSE_I1 = np.sqrt(MSE_I1)
p_RMSE_I1 = (RMSE_I1 / 250) * 100

print(RMSE_I1)
print(p_RMSE_I1)

"""### Mean"""

DatosPIM = DatosPI2.copy()

cont= 0
for i in range(0, len(DatosPIM.index)):

  if DatosPIM.iloc[i, 0] == 600:

    old_data2 = DatosPIM[DatosPIM["Date"].apply(lambda x: x.hour == DatosPIM['Hour'].iloc[i] and x < DatosPIM["Date"].iloc[i])]
    Prom = old_data2['Generacion_(kWh)'].mean()
    DatosPIM['Generacion_(kWh)'].iloc[i] = Prom

DatosPIM.head()

# Plotting Generation
plt.figure(figsize=(10, 3))
plt.plot(DatosPI['Generacion_(kWh)'], color='darkblue')
plt.plot(DatosPIM['Generacion_(kWh)'], color='darkorange')

plt.xlabel('Dates')
plt.ylabel('Generation (kWh)')
plt.gca().set_facecolor('white')

plt.grid(True, color='lightgray')
plt.show()

total = DatosPIM.isna().sum().sort_values(ascending=False)
percent_1 = DatosPIM.isna().sum()/DatosPIM.isna().count()*100
percent_2 = (round(percent_1, 1)).sort_values(ascending=False)
missing_data = pd.concat([total, percent_2], axis=1, keys=['Total', '%'])
missing_data.head(DatosPIM.size)

MSE_I2 = mean_squared_error(DatosPI['Generacion_(kWh)'], DatosPIM['Generacion_(kWh)'])

RMSE_I2 = np.sqrt(MSE_I2)
p_RMSE_I2 = (RMSE_I2 / 250) * 100

print(RMSE_I2)
print(p_RMSE_I2)

"""### Median"""

DatosPIMd = DatosPI2.copy()

cont= 0
for i in range(0, len(DatosPIMd.index)):

  if DatosPIMd.iloc[i, 0] == 600:

    old_data3 = DatosPIMd[DatosPIMd["Date"].apply(lambda x: x.hour == DatosPIMd['Hour'].iloc[i] and x < DatosPIMd["Date"].iloc[i])]
    Prom = old_data3['Generacion_(kWh)'].median()
    DatosPIMd['Generacion_(kWh)'].iloc[i] = Prom

DatosPIMd.head()

# Plotting Generation
plt.figure(figsize=(10, 3))
plt.plot(DatosPI['Generacion_(kWh)'], color='darkblue')
plt.plot(DatosPIMd['Generacion_(kWh)'], color='darkorange')

plt.xlabel('Dates')
plt.ylabel('Generation (kWh)')
plt.gca().set_facecolor('white')

plt.grid(True, color='lightgray')
plt.show()

total = DatosPIMd.isna().sum().sort_values(ascending=False)
percent_1 = DatosPIMd.isna().sum()/DatosPIMd.isna().count()*100
percent_2 = (round(percent_1, 1)).sort_values(ascending=False)
missing_data = pd.concat([total, percent_2], axis=1, keys=['Total', '%'])
missing_data.head(DatosPIMd.size)

MSE_I3 = mean_squared_error(DatosPI['Generacion_(kWh)'], DatosPIMd['Generacion_(kWh)'])

RMSE_I3 = np.sqrt(MSE_I3)
p_RMSE_I3 = (RMSE_I3 / 250) * 100

print(RMSE_I3)
print(p_RMSE_I3)

"""Performance comparison"""

method1 = [RMSE_I1, p_RMSE_I1]
method2 = [RMSE_I2, p_RMSE_I2]
method3 = [RMSE_I3, p_RMSE_I3]

results = {'Average MW': method1, 'Mean': method2, 'Median': method3}
results_table = pd.DataFrame(results, index=['MSE', 'P RMSE'])
print(results_table)

"""### Selected method

The Average with Moving Window method was chosen because, unlike other models, it does not require the use of all previous data, yet it performs similarly or better than other methods.
"""

DatosI = Datos.copy()
DatosI.head()

cont= 0
for i in range(0, len(DatosI.index)):
  #cont = cont + 1
  #print(cont)
  if DatosI.iloc[i, 0] == 1000:

    old_data = DatosI[DatosI["Date"].apply(lambda x: x.hour == DatosI['Hour'].iloc[i] and x < DatosI["Date"].iloc[i])]
    Prom = (old_data['Generacion_(kWh)'][-60:-30].mean())*0.7 + (old_data['Generacion_(kWh)'][-30:].mean())*0.3

    if Prom >= 200:

      Prom = Prom + abs(np.random.normal(loc=104.3, scale=83.52, size=1))*0.05

    DatosI['Generacion_(kWh)'].iloc[i] = Prom

DatosI.head()

total = DatosI.isna().sum().sort_values(ascending=False)
percent_1 = DatosI.isna().sum()/DatosI.isna().count()*100
percent_2 = (round(percent_1, 1)).sort_values(ascending=False)
missing_data = pd.concat([total, percent_2], axis=1, keys=['Total', '%'])
missing_data.head(DatosI.size)

# Plotting Generation
plt.figure(figsize=(10, 3))
plt.plot(DatosI['Generacion_(kWh)'])
plt.plot(DatosI['Generacion_(kWh)'], color='darkorange')

plt.xlabel('Dates')
plt.ylabel('Generation (kWh)')
plt.gca().set_facecolor('white')

plt.grid(True, color='lightgray')
plt.show()

print(min(DatosI['Generacion_(kWh)']))

rd= abs(np.random.normal(loc=104.3, scale=83.52, size=1))*0.1
print(rd)

del(DatosI['Date'])
DatosI.head()

"""Download complete data"""

DatosI.to_excel('CompleteData.xlsx', sheet_name='Data')

"""## Load complete data"""

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

DatosF = pd.read_excel('/content/drive/My Drive/GitHub/PVPGF/CompleteData.xlsx', index_col=0)
DatosF.head(23000)

# Plotting Generation
plt.figure(figsize=(6, 1.8))
plt.plot(DatosF['Generacion_(kWh)'])
plt.plot(DatosF['Generacion_(kWh)'], color='#EC7C30')

plt.xlabel('Time (hour)')
plt.ylabel('Generation (kWh)')
plt.gca().set_facecolor('white')

fecha_minima = pd.Timestamp('2018-05-01 06:00:00')
fecha_maxima = pd.Timestamp('2023-02-28 18:00:00')
plt.xlim(fecha_minima, fecha_maxima)
plt.xticks(rotation=15, ha="right")

plt.grid(True, color='lightgray')
plt.show()

"""## Average Annual Generation"""

DatosF_Anual = DatosF.groupby(pd.Grouper(freq='Y'))['Generacion_(kWh)'].mean()
DatosF_Anual.index = DatosF_Anual.index.year

plt.figure(figsize=(10, 3))
plt.plot(DatosF_Anual, color='#EC7C30')

plt.xlabel('Years')
plt.ylabel('Average Annual Generation (kWh)')
plt.style.use('ggplot')
plt.gca().set_facecolor('white')

plt.grid(True, color='lightgray')
plt.show()

"""## Generation Histogram"""

intervals = [0,10,20,30,40,50,60,70,80,90,100,110,120,130,140,150,160,170,180,
              190,200,210,220,230,240,250,260,270,280,290,300] #calculamos los extremos de los intervalos

plt.figure(figsize=(13, 3))
datos = pd.Series(DatosF['Generacion_(kWh)'])
plt.hist(x=DatosF['Generacion_(kWh)'], bins=intervals, color='#EC7C30', rwidth=0.85)
plt.xticks(intervals)
plt.ylabel('Frecuency')
plt.xlabel('Generation Intervals(kWh)')
plt.title('Generation Histogram')

plt.style.use('ggplot')
plt.gca().set_facecolor('white')
plt.grid(True, color='lightgray')

plt.show()

"""## Decomposing the time series
Trend, Seasonality and Residual
"""

generacion_decomposed = seasonal_decompose(DatosF['Generacion_(kWh)'],model='additive', period=13)

plt.figure(figsize=(12, 8))
plt.subplot(4, 1, 1)
plt.plot(DatosF['Generacion_(kWh)'], label='Data', color='#EC7C30')
plt.legend(loc='upper left')
plt.gca().set_facecolor('white')
plt.grid(True, color='lightgray')
plt.subplot(4, 1, 2)
plt.plot(generacion_decomposed.trend, label='Trend', color='#C85103')
plt.legend(loc='upper left')
plt.gca().set_facecolor('white')
plt.grid(True, color='lightgray')
plt.subplot(4, 1, 3)
plt.plot(generacion_decomposed.seasonal, label='Seasonality', color='#DA6220')
plt.legend(loc='upper left')
plt.gca().set_facecolor('white')
plt.grid(True, color='lightgray')
plt.subplot(4, 1, 4)
plt.plot(generacion_decomposed.resid, label='Residual', color='#F9943B')
plt.legend(loc='upper left')
plt.gca().set_facecolor('white')
plt.grid(True, color='lightgray')
plt.tight_layout()
plt.show()

generacion_decomposed = seasonal_decompose(DatosF['Generacion_(kWh)'][-767:-1],model='additive', period=13)


plt.figure(figsize=(10, 8))
plt.subplot(4, 1, 1)
plt.plot(DatosF['Generacion_(kWh)'][-767:-1], label='Data', color='#EC7C30')
plt.legend(loc='upper left')
plt.gca().set_facecolor('white')
plt.grid(True, color='lightgray')
plt.subplot(4, 1, 2)
plt.plot(generacion_decomposed.trend, label='Trend', color='#C85103')
plt.legend(loc='upper left')
plt.gca().set_facecolor('white')
plt.grid(True, color='lightgray')
plt.subplot(4, 1, 3)
plt.plot(generacion_decomposed.seasonal, label='Seasonality', color='#DA6220')
plt.legend(loc='upper left')
plt.gca().set_facecolor('white')
plt.grid(True, color='lightgray')
plt.subplot(4, 1, 4)
plt.plot(generacion_decomposed.resid, label='Residual', color='#F9943B')
plt.legend(loc='upper left')
plt.gca().set_facecolor('white')
plt.grid(True, color='lightgray')
plt.tight_layout()
plt.show()

"""## Testing Stationarity

The ADF statistic must be a large negative number and the p-value must be less than 0.05.
"""

ADF_result = adfuller(DatosF['Generacion_(kWh)'])
print(f'ADF Statistic: {ADF_result[0]}')
print(f'p-value: {ADF_result[1]}')

"""## Data seasonality

By month:
"""

sns.set(rc={'figure.figsize':(10, 5)})
sns.set_style("whitegrid")
sns.boxplot(data=DatosF,x='Month',y='Generacion_(kWh)')

"""Hourly:"""

sns.set(rc={'figure.figsize':(10, 5)})
sns.set_style("whitegrid")
sns.boxplot(data=DatosF,x='Hour',y='Generacion_(kWh)')

"""## Dataset division"""

DatosM = pd.DataFrame({'Generacion_(kWh)': DatosF['Generacion_(kWh)']})
train = DatosM[:-4745]
test  = DatosM[-4745:] #20.68%

print(f"Fechas train : {train.index.min()} --- {train.index.max()}  (n={len(train)})")
print(f"Fechas test  : {test.index.min()} --- {test.index.max()}  (n={len(test)})")

"""# Model Training

## Model 1: SARIMA

### Autocorrelation Function

The analysis reveals a moving average process and suggests that an autoregressive process is being studied.
"""

plot_acf(DatosF['Generacion_(kWh)'], color='#EC7C30')
plt.gca().set_facecolor('white')
plt.grid(True, color='lightgray')
plot_pacf(DatosF['Generacion_(kWh)'], color='#EC7C30')
plt.gca().set_facecolor('white')
plt.grid(True, color='lightgray')
plt.show()

"""ADF test for non-differenced data"""

ADF_result = adfuller(DatosF['Generacion_(kWh)'])
print(f'ADF Statistic: {ADF_result[0]}')
print(f'p-value: {ADF_result[1]}')

"""ADF test for data differentiated once"""

generacion_diff = np.diff(DatosF['Generacion_(kWh)'], n=1)
ADF_result = adfuller(generacion_diff)
print(f'ADF Statistic: {ADF_result[0]}')
print(f'p-value: {ADF_result[1]}')

plot_acf(generacion_diff)
plot_pacf(generacion_diff)
plt.show()

"""### Train"""

trainSARIMA = train.copy()

DatosM1 = pd.DataFrame({'Generacion_(kWh)': trainSARIMA['Generacion_(kWh)']})

# Specify window size
window_size = 13*14

all_predictions = []
all_test_data = []

# Split the time series into windows
n_windows = int(len(DatosM1) / window_size)
for i in range(n_windows):

    train_data = DatosM1.iloc[i*window_size : (i+1)*window_size]
    print(train_data.shape)

    # Create a SARIMA model
    modelSARIMA = SARIMAX(train_data, order=(2, 1, 1), seasonal_order=(2, 1, 1, 13))

    # Fit the model to the training data
    resultsSARIMA = modelSARIMA.fit()

    # Perform forecast for validation data
    predictionsSARIMA = resultsSARIMA.predict(start=0, end=len(train_data)-1, dynamic=False)
    print(predictionsSARIMA.shape)

    # Store forecast and validation results in the corresponding lists
    all_predictions.extend(predictionsSARIMA)
    all_test_data.extend(train_data['Generacion_(kWh)'].tolist())

    # Display training data and forecasting data
    fig = go.Figure()
    fig = make_subplots(rows=1, cols=1)
    fig.add_trace(go.Scatter(x=train_data.index, y=train_data["Generacion_(kWh)"],
                    mode='lines', line=dict(width=2.5, color='#145DA0'), name="Training data", stackgaps='infer zero'), row=1, col=1)
    fig.add_trace(go.Scatter(x=train_data.index, y=predictionsSARIMA,
                    mode='lines', line=dict(width=2.5, color='#EC7C30'), name="Forecast", stackgaps='infer zero'), row=1, col=1)
    fig.update_layout(title='',
                      paper_bgcolor='rgba(0,0,0,0)',
                      plot_bgcolor='rgba(0,0,0,0)',
                      width=1200,height=500,
                      yaxis=dict(color="black"),
                      xaxis=dict(color="black"),
                      font=dict(family="Fira Sans, Condensed", color='black'),
                      legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=25, font_color='black'),
                      showlegend=True)
    fig.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
    fig.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
    fig.show()


    # Calculate errors for current window
    mse = mean_squared_error(train_data, predictionsSARIMA)
    mae = mean_absolute_error(train_data, predictionsSARIMA)
    p_mae = (mae / 250) * 100
    rmse = np.sqrt(mse)
    p_rmse = (rmse / 250) * 100
    r2 = r2_score(train_data, predictionsSARIMA)

    print("Root Mean Square Error:", rmse)
    print('P RMSE: %f' % p_rmse)
    print('------')
    print('MSE: %f' % mse)
    print('------')
    print('MAE: %f' % mae)
    print('P MAE: %f' % p_mae)
    print('------')
    print('R2 Score: %f' % r2)

all_predictions = np.clip(all_predictions, a_min=0, a_max=None)

# Calculate errors for all validation data
mse1 = mean_squared_error(all_test_data, all_predictions)
mae1 = mean_absolute_error(all_test_data, all_predictions)
p_mae1 = (mae1 / 250) * 100
rmse1 = np.sqrt(mse1)
p_rmse1 = (rmse1 / 250) * 100
r21 = r2_score(all_test_data, all_predictions)

print("Root Mean Square Error:", rmse1)
print('P RMSE: %f' % p_rmse1)
print('------')
print('MSE: %f' % mse1)
print('------')
print('MAE: %f' % mae1)
print('P MAE: %f' % p_mae1)
print('------')
print('R2 Score: %f' % r21)

# Plotting the results
datos1=np.array(range(0, 18200))

fig2 = go.Figure()
fig2 = make_subplots(rows=1, cols=1)
fig2.add_trace(go.Scatter(x=datos1, y=all_test_data,
                mode='lines', line=dict(width=2, color='#145DA0'), name="Real power generation", stackgaps='infer zero'), row=1, col=1)
fig2.add_trace(go.Scatter(x=datos1, y=all_predictions,
                mode='lines', line=dict(width=2, color='#EC7C30'), name="Predicted power generation", stackgaps='infer zero'), row=1, col=1)
fig2.update_layout(title='',
                  paper_bgcolor='rgba(0,0,0,0)',
                  plot_bgcolor='rgba(0,0,0,0)',
                  width=1200,height=600,
                  yaxis=dict(color="black"),
                  xaxis=dict(color="black"),
                  font=dict(family="Fira Sans, Condensed", color='black'),
                  legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=23, font_color='black'),
                  showlegend=True)
fig2.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
fig2.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
fig2.show()

"""## Model 2: LSTM

### Train
"""

trainLSTM = train.copy()
tf.random.set_seed(42)

DatosM2 = pd.DataFrame({'Generacion_(kWh)': trainLSTM['Generacion_(kWh)']})

#Normalize data
scaler = MinMaxScaler(feature_range=(-1,1))
DatosM2n = scaler.fit_transform(DatosM2)

seq_length = 13*14
out_length = 13

#Series conversion in X and Y sequence

def series_to_supervised(data, n_in=1, n_out=1, dropnan=True):
   n_vars = 1 if type(data) is list else data.shape[1]
   df = pd.DataFrame(data)
   cols, names = list(), list()
   # input sequence (t-n, ... t-1)
   for i in range(n_in, 0, -1):
    cols.append(df.shift(i))
    names += [('var%d(t-%d)' % (j+1, i)) for j in range(n_vars)]
   # forecast sequence (t, t+1, ... t+n)
   for i in range(0, n_out):
    cols.append(df.shift(-i))
    if i == 0:
      names += [('var%d(t)' % (j+1)) for j in range(n_vars)]
    else:
      names += [('var%d(t+%d)' % (j+1, i)) for j in range(n_vars)]
    # put it all together
    agg = pd.concat(cols, axis=1)
    agg.columns = names
    # drop rows with NaN values
    if dropnan:
      agg.dropna(inplace=True)
   return agg

data_train_LSTM = series_to_supervised(DatosM2n, seq_length, out_length)
print(data_train_LSTM.shape)

X_train_LSTM = data_train_LSTM.values[:, 0:seq_length]
y_train_LSTM = data_train_LSTM.values[:, seq_length:]
print(X_train_LSTM.shape, y_train_LSTM.shape)
X_train_LSTM= X_train_LSTM.reshape(X_train_LSTM.shape[0], X_train_LSTM.shape[1], 1)
print(X_train_LSTM.shape, y_train_LSTM.shape)

# LSTM model creation
modelLSTM = Sequential()
modelLSTM.add(LSTM(64, activation= 'tanh', input_shape=(seq_length, 1), return_sequences = True))
#modelLSTM.add(Dropout(0.2))
modelLSTM.add(LSTM(45, activation= 'tanh', return_sequences = True))
#modelLSTM.add(Dropout(0.2))
modelLSTM.add(LSTM(32, activation= 'tanh'))
modelLSTM.add(Dense(13))
modelLSTM.compile(optimizer='adam', loss='mse')

modelLSTM.summary()

callbacksLSTM = [EarlyStopping(patience=10, monitor='val_loss', mode='auto', restore_best_weights=True),\
                 ReduceLROnPlateau(monitor='val_loss', patience = 2, verbose = 1, factor = 0.8, min_lr = 1e-5),\
                 CSVLogger('Train_Data.csv', separator=',', append=True),\
                 ModelCheckpoint('best_modelLSTM.h5', monitor='loss', save_best_only=True, verbose=1)]

# Model training
modelLSTM.fit(X_train_LSTM, y_train_LSTM, epochs=30, verbose=1, callbacks=[callbacksLSTM], validation_split=0.2)

loss_per_epoch = modelLSTM.history.history['loss']
val_loss_per_epoch = modelLSTM.history.history['val_loss']
plt.plot(range(len(loss_per_epoch)),loss_per_epoch)
plt.plot(range(len(val_loss_per_epoch)),val_loss_per_epoch)

img_LSTM = 'model_LSTM.png'
tf.keras.utils.plot_model(modelLSTM, to_file=img_LSTM, show_shapes=True)

"""### Test"""

modelLSTM = keras.models.load_model('best_modelLSTM.h5')

pred_LSTM = scaler.inverse_transform(modelLSTM.predict(X_train_LSTM))
real_data = scaler.inverse_transform(y_train_LSTM)

pred_LSTM = np.clip(pred_LSTM, a_min=0, a_max=None)

print(pred_LSTM.shape[0])

# estimate errors
mse22 = mean_squared_error(real_data, pred_LSTM)
rmse22 = np.sqrt(mse22)
p_rmse22 = (rmse22 / 250) * 100
mae22 = mean_absolute_error(real_data, pred_LSTM)
p_mae22 = (mae22 / 250) * 100
r222 = r2_score(real_data, pred_LSTM)

# print errors
print("Root Mean Square Error:", rmse22)
print('P RMSE: %f' % p_rmse22)
print('------')
print('MSE:', mse22)
print('------')
print('MAE:', mae22)
print('P MAE: %f' % p_mae22)
print('------')
print('R2 Score: %f' % r222)

# Plotting the results
datos2=np.array(range(0, 18006))

fig3 = go.Figure()
fig3 = make_subplots(rows=1, cols=1)
fig3.add_trace(go.Scatter(x=datos2, y=real_data[:,0],
                mode='lines', line=dict(width=2, color='#145DA0'), name="Real power generation", stackgaps='infer zero'), row=1, col=1)
fig3.add_trace(go.Scatter(x=datos2, y=pred_LSTM[:,0],
                mode='lines', line=dict(width=2, color='#EC7C30'), name="Predicted power generation", stackgaps='infer zero'), row=1, col=1)
fig3.update_layout(title='',
                  paper_bgcolor='rgba(0,0,0,0)',
                  plot_bgcolor='rgba(0,0,0,0)',
                  width=1200,height=600,
                  yaxis=dict(color="black"),
                  xaxis=dict(color="black"),
                  font=dict(family="Fira Sans, Condensed", color='black'),
                  legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=23, font_color='black'),
                  showlegend=True)
fig3.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
fig3.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
fig3.show()

datos2=np.array(range(0, 18006))

fig3 = go.Figure()
fig3 = make_subplots(rows=1, cols=1)
fig3.add_trace(go.Scatter(x=datos2, y=real_data[2000-182:2000,0],
                mode='lines', line=dict(width=2, color='#145DA0'), name="Real power generation", stackgaps='infer zero'), row=1, col=1)
fig3.add_trace(go.Scatter(x=datos2, y=pred_LSTM[2000-182:2000,0],
                mode='lines', line=dict(width=2, color='#EC7C30'), name="Predicted power generation", stackgaps='infer zero'), row=1, col=1)
fig3.update_layout(title='',
                  paper_bgcolor='rgba(0,0,0,0)',
                  plot_bgcolor='rgba(0,0,0,0)',
                  width=1200,height=500,
                  yaxis=dict(color="black"),
                  xaxis=dict(color="black"),
                  font=dict(family="Fira Sans, Condensed", color='black'),
                  legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=25, font_color='black'),
                  showlegend=True)
fig3.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
fig3.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
fig3.show()

"""## Model 3: XGBoost

### Train
"""

trainXG = train.copy()

seq_length = 13*14
out_length = 13

data_train_XG = series_to_supervised(trainXG, seq_length, out_length)
print(data_train_XG.shape)

X_train_XG = data_train_XG.values[:, 0:seq_length]
y_train_XG = data_train_XG.values[:, seq_length:]
print(X_train_XG.shape, y_train_XG.shape)

# Specify window size
window_size = 13*14

all_predictionsXG = []
all_test_dataXG = []


# Split the time series into windows
n_windows = int(len(y_train_XG) / window_size)
for i in range(n_windows):
    train_XG = y_train_XG[i*window_size : (i+1)*window_size]

    X_trainXG = train_XG.copy()
    y_trainXG = train_XG.copy()

    # Create a XGBoost model
    modelXG = XGBRegressor(objective= 'reg:squarederror',  # objective function for regression problems
    learning_rate= 0.1,  # learning rate
    max_depth= 3,  # maximum depth of tree
    n_estimators= 100  # number of trees in the model
    )

    # Fit the model to the training data
    resultsXG = modelXG.fit(X_trainXG, y_trainXG)

    # Perform forecast for validation data
    predictionsXG = resultsXG.predict(X_trainXG)
    print(predictionsXG.shape)

    # Store forecast and validation results in the corresponding lists
    all_predictionsXG.extend(predictionsXG[:,0])
    all_test_dataXG.extend(y_trainXG[:,0].tolist())

    # Display training data and forecasting data
    datos4=np.array(range(0, 182))

    fig = go.Figure()
    fig = make_subplots(rows=1, cols=1)
    fig.add_trace(go.Scatter(x=datos4, y=y_trainXG[:,0],
                    mode='lines', line=dict(width=2.5, color='#145DA0'), name="Training data", stackgaps='infer zero'), row=1, col=1)
    fig.add_trace(go.Scatter(x=datos4, y=predictionsXG[:,0],
                    mode='lines', line=dict(width=2.5, color='#EC7C30'), name="Forecast", stackgaps='infer zero'), row=1, col=1)
    fig.update_layout(title='',
                      paper_bgcolor='rgba(0,0,0,0)',
                      plot_bgcolor='rgba(0,0,0,0)',
                      width=1200,height=500,
                      yaxis=dict(color="black"),
                      xaxis=dict(color="black"),
                      font=dict(family="Fira Sans, Condensed", color='black'),
                      legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=25, font_color='black'),
                      showlegend=True)
    fig.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
    fig.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
    fig.show()

    # Calculate errors for current window
    mse = mean_squared_error(train_XG, predictionsXG)
    mae = mean_absolute_error(train_XG, predictionsXG)
    p_mae = (mae / 250) * 100
    rmse = np.sqrt(mse)
    p_rmse = (rmse / 250) * 100
    r2 = r2_score(train_XG, predictionsXG)

    print("Root Mean Square Error:", rmse)
    print('P RMSE: %f' % p_rmse)
    print('------')
    print('MSE: %f' % mse)
    print('------')
    print('MAE: %f' % mae)
    print('P MAE: %f' % p_mae)
    print('------')
    print('R2 Score: %f' % r2)
    print(i)

modelXG.save_model("xgboost.json")

modelXG2 = xgb.Booster()
modelXG2.load_model("xgboost.json")

all_predictionsXG = np.clip(all_predictionsXG, a_min=0, a_max=None)


# Calculate errors for all validation data
mse3 = mean_squared_error(all_test_dataXG, all_predictionsXG)
mae3 = mean_absolute_error(all_test_dataXG, all_predictionsXG)
p_mae3 = (mae3 / 250) * 100
rmse3 = np.sqrt(mse3)
p_rmse3 = (rmse3 / 250) * 100
r23 = r2_score(all_test_dataXG, all_predictionsXG)

print("Root Mean Square Error:", rmse3)
print('P RMSE: %f' % p_rmse3)
print('------')
print('MSE: %f' % mse3)
print('------')
print('MAE: %f' % mae3)
print('P MAE: %f' % p_mae3)
print('------')
print('R2 Score: %f' % r23)

datos5=np.array(range(0, 18200))

fig5 = go.Figure()
fig5 = make_subplots(rows=1, cols=1)
fig5.add_trace(go.Scatter(x=datos5, y=all_test_dataXG,
                mode='lines', line=dict(width=2, color='#145DA0'), name="Real power generation", stackgaps='infer zero'), row=1, col=1)
fig5.add_trace(go.Scatter(x=datos5, y=all_predictionsXG,
                mode='lines', line=dict(width=2, color='#EC7C30'), name="Predicted power generation", stackgaps='infer zero'), row=1, col=1)
fig5.update_layout(title='',
                  paper_bgcolor='rgba(0,0,0,0)',
                  plot_bgcolor='rgba(0,0,0,0)',
                  width=1200,height=500,
                  yaxis=dict(color="black"),
                  xaxis=dict(color="black"),
                  font=dict(family="Fira Sans, Condensed", color='black'),
                  legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=23, font_color='black'),
                  showlegend=True)
fig5.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
fig5.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
fig5.show()

"""# Model Validation

### SARIMA
"""

testSARIMA = test.copy()

predictions = resultsSARIMA.predict(start=len(train_data), end=len(train_data)+len(testSARIMA)-1, dynamic=False)
print(predictions.shape)

window_size = 13*14

all_predictions2 = []
all_test_data2 = []

n_windows = int(len(testSARIMA) / window_size)
for i in range(n_windows):

    train_data2 = testSARIMA.iloc[i*window_size : (i+1)*window_size]

    # Forecast validation data
    predictions = resultsSARIMA.predict(start=0, end=len(train_data2)-1, dynamic=False)
    print(predictions.shape)

    # Store forecast and validation results in the corresponding lists
    all_predictions2.extend(predictions)
    all_test_data2.extend(train_data2['Generacion_(kWh)'].tolist())

    # Display validation and forecast data
    fig = go.Figure()
    fig = make_subplots(rows=1, cols=1)
    fig.add_trace(go.Scatter(x=train_data2.index, y=train_data2["Generacion_(kWh)"],
                    mode='lines', line=dict(width=2.5, color='#145DA0'), name="Validation data", stackgaps='infer zero'), row=1, col=1)
    fig.add_trace(go.Scatter(x=train_data2.index, y=predictionsSARIMA,
                    mode='lines', line=dict(width=2.5, color='#EC7C30'), name="Forecast", stackgaps='infer zero'), row=1, col=1)
    fig.update_layout(title='',
                      paper_bgcolor='rgba(0,0,0,0)',
                      plot_bgcolor='rgba(0,0,0,0)',
                      width=1200,height=500,
                      yaxis=dict(color="black"),
                      xaxis=dict(color="black"),
                      font=dict(family="Fira Sans, Condensed", color='black'),
                      legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=25, font_color='black'),
                      showlegend=True)
    fig.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
    fig.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
    fig.show()


    # Calculate errors for the current window
    mse = mean_squared_error(train_data2, predictions)
    mae = mean_absolute_error(train_data2, predictions)
    p_mae = (mae / 250) * 100
    rmse = np.sqrt(mse)
    p_rmse = (rmse / 250) * 100
    r2 = r2_score(train_data2, predictions)

    print("Root Mean Square Error:", rmse)
    print('P RMSE: %f' % p_rmse)
    print('------')
    print('MSE: %f' % mse)
    print('------')
    print('MAE: %f' % mae)
    print('P MAE: %f' % p_mae)
    print('------')
    print('R2 Score: %f' % r2)

all_predictions2 = np.clip(all_predictions2, a_min=0, a_max=None)

# Calculate errors for all validation data
mseS = mean_squared_error(all_test_data2, all_predictions2)
maeS = mean_absolute_error(all_test_data2, all_predictions2)
p_maeS = (maeS / 250) * 100
rmseS = np.sqrt(mseS)
p_rmseS = (rmseS / 250) * 100
r2S = r2_score(all_test_data2, all_predictions2)

print("Root Mean Square Error:", rmseS)
print('P RMSE: %f' % p_rmseS)
print('------')
print('MSE: %f' % mseS)
print('------')
print('MAE: %f' % maeS)
print('P MAE: %f' % p_maeS)
print('------')
print('R2 Score: %f' % r2S)

datos1=np.array(range(0, 4732))

fig2 = go.Figure()
fig2 = make_subplots(rows=1, cols=1)
fig2.add_trace(go.Scatter(x=datos1, y=all_test_data2,
                mode='lines', line=dict(width=2, color='#145DA0'), name="Real power generation", stackgaps='infer zero'), row=1, col=1)
fig2.add_trace(go.Scatter(x=datos1, y=all_predictions2,
                mode='lines', line=dict(width=2, color='#EC7C30'), name="Predicted power generation", stackgaps='infer zero'), row=1, col=1)
fig2.update_layout(title='',
                  paper_bgcolor='rgba(0,0,0,0)',
                  plot_bgcolor='rgba(0,0,0,0)',
                  width=1200,height=600,
                  yaxis=dict(color="black"),
                  xaxis=dict(color="black"),
                  font=dict(family="Fira Sans, Condensed", color='black'),
                  legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=23, font_color='black'),
                  showlegend=True)
fig2.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
fig2.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
fig2.show()

"""## LSTM"""

testLSTM = test.copy()

# Normalize data
scaler = MinMaxScaler(feature_range=(-1,1))
DatosM2nV = scaler.fit_transform(testLSTM)

seq_length = 13*14
out_length = 13

data_train_LSTM_V = series_to_supervised(DatosM2nV, seq_length, out_length)
print(data_train_LSTM_V.shape)

X_train_LSTM_V = data_train_LSTM_V.values[:, 0:seq_length]
y_train_LSTM_V = data_train_LSTM_V.values[:, seq_length:]
print(X_train_LSTM_V.shape, y_train_LSTM_V.shape)
X_train_LSTM_V= X_train_LSTM_V.reshape(X_train_LSTM_V.shape[0], X_train_LSTM_V.shape[1], 1)
print(X_train_LSTM_V.shape, y_train_LSTM_V.shape)

model_LSTM_V = keras.models.load_model('best_modelLSTM.h5')

pred_LSTM_V = scaler.inverse_transform(model_LSTM_V.predict(X_train_LSTM_V))
real_data_V = scaler.inverse_transform(y_train_LSTM_V)

pred_LSTM_V = np.clip(pred_LSTM_V, a_min=0, a_max=None)

mse2L = mean_squared_error(real_data_V, pred_LSTM_V)
rmse2L = np.sqrt(mse2L)
p_rmse2L = (rmse2L / 250) * 100
mae2L = mean_absolute_error(real_data_V, pred_LSTM_V)
p_mae2L = (mae2L / 250) * 100
r22L = r2_score(real_data_V, pred_LSTM_V)

# print errors
print("Root Mean Square Error:", rmse2L)
print('P RMSE: %f' % p_rmse2L)
print('------')
print('MSE:', mse2L)
print('------')
print('MAE:', mae2L)
print('P MAE: %f' % p_mae2L)
print('------')
print('R2 Score: %f' % r22L)

datos3=np.array(range(0, 4745))

fig2 = go.Figure()
fig2 = make_subplots(rows=1, cols=1)
fig2.add_trace(go.Scatter(x=datos3, y=real_data_V[:,0],
                mode='lines', line=dict(width=2, color='#145DA0'), name="Real power generation", stackgaps='infer zero'), row=1, col=1)
fig2.add_trace(go.Scatter(x=datos3, y=pred_LSTM_V[:,0],
                mode='lines', line=dict(width=2, color='#EC7C30'), name="Predicted power generation", stackgaps='infer zero'), row=1, col=1)
fig2.update_layout(title='',
                  paper_bgcolor='rgba(0,0,0,0)',
                  plot_bgcolor='rgba(0,0,0,0)',
                  width=1200,height=500,
                  yaxis=dict(color="black"),
                  xaxis=dict(color="black"),
                  font=dict(family="Fira Sans, Condensed", color='black'),
                  legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=25, font_color='black'),
                  showlegend=True)
fig2.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
fig2.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
fig2.show()

datos3=np.array(range(0, 4551))

fig2 = go.Figure()
fig2 = make_subplots(rows=1, cols=1)
fig2.add_trace(go.Scatter(x=datos3, y=real_data_V[0:182,0],
                mode='lines', line=dict(width=2, color='#145DA0'), name="Real power generation", stackgaps='infer zero'), row=1, col=1)
fig2.add_trace(go.Scatter(x=datos3, y=pred_LSTM_V[0:182,0],
                mode='lines', line=dict(width=2, color='#EC7C30'), name="Predicted power generation", stackgaps='infer zero'), row=1, col=1)
fig2.update_layout(title='',
                  paper_bgcolor='rgba(0,0,0,0)',
                  plot_bgcolor='rgba(0,0,0,0)',
                  width=1200,height=500,
                  yaxis=dict(color="black"),
                  xaxis=dict(color="black"),
                  font=dict(family="Fira Sans, Condensed", color='black'),
                  legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=23, font_color='black'),
                  showlegend=True)
fig2.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
fig2.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
fig2.show()

"""## XGBoost"""

testXG = test.copy()

seq_length = 13*14
out_length = 13

data_vald_XG = series_to_supervised(testXG, seq_length, out_length)
print(data_vald_XG.shape)

X_val_XG = data_vald_XG.values[:, 0:seq_length]
y_val_XG = data_vald_XG.values[:, seq_length:]
print(X_val_XG.shape, y_val_XG.shape)

window_size = 13*14

all_predictionsXG2 = []
all_test_dataXG2 = []


# Split the time series into windows
n_windows = int(len(y_val_XG) / window_size)
for i in range(n_windows):

    train_XG2 = y_val_XG[i*window_size : (i+1)*window_size]

    X_trainXG2 = train_XG2.copy()
    y_trainXG2 = train_XG2.copy()

    # Forecast for validation data

    predictionsXG2 = resultsXG.predict(X_trainXG2)
    print(predictionsXG2.shape)


    # Store forecast and validation results in the corresponding lists
    all_predictionsXG2.extend(predictionsXG2[:,0])
    all_test_dataXG2.extend(y_trainXG2[:,0].tolist())

    datos4=np.array(range(0, 182))

    fig = go.Figure()
    fig = make_subplots(rows=1, cols=1)
    fig.add_trace(go.Scatter(x=datos4, y=y_trainXG2[:,0],
                    mode='lines', line=dict(width=2.5, color='#145DA0'), name="Validation data", stackgaps='infer zero'), row=1, col=1)
    fig.add_trace(go.Scatter(x=datos4, y=predictionsXG2[:,0],
                    mode='lines', line=dict(width=2.5, color='#EC7C30'), name="Forecast", stackgaps='infer zero'), row=1, col=1)
    fig.update_layout(title='',
                      paper_bgcolor='rgba(0,0,0,0)',
                      plot_bgcolor='rgba(0,0,0,0)',
                      width=1000,height=500,
                      yaxis=dict(color="black"),
                      xaxis=dict(color="black"),
                      font=dict(family="Fira Sans, Condensed", color='black'),
                      legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=25, font_color='black'),
                      showlegend=True)
    fig.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
    fig.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
    fig.show()

    # Calculate errors for the current window
    mse = mean_squared_error(train_XG2, predictionsXG2)
    mae = mean_absolute_error(train_XG2, predictionsXG2)
    p_mae = (mae / 250) * 100
    rmse = np.sqrt(mse)
    p_rmse = (rmse / 250) * 100
    r2 = r2_score(train_XG2, predictionsXG2)

    print("Root Mean Square Error:", rmse)
    print('P RMSE: %f' % p_rmse)
    print('------')
    print('MSE: %f' % mse)
    print('------')
    print('MAE: %f' % mae)
    print('P MAE: %f' % p_mae)
    print('------')
    print('R2 Score: %f' % r2)

all_predictionsXG2 = np.clip(all_predictionsXG2, a_min=0, a_max=None)

# Calculate errors for all validation data
mseX = mean_squared_error(all_test_dataXG2, all_predictionsXG2)
maeX = mean_absolute_error(all_test_dataXG2, all_predictionsXG2)
p_maeX = (maeX / 250) * 100
rmseX = np.sqrt(mseX)
p_rmseX = (rmseX / 250) * 100
r2X = r2_score(all_test_dataXG2, all_predictionsXG2)

print("Root Mean Square Error:", rmseX)
print('P RMSE: %f' % p_rmseX)
print('------')
print('MSE: %f' % mseX)
print('------')
print('MAE: %f' % maeX)
print('P MAE: %f' % p_maeX)
print('------')
print('R2 Score: %f' % r2X)

datos5=np.array(range(0, 4550))

fig5 = go.Figure()
fig5 = make_subplots(rows=1, cols=1)
fig5.add_trace(go.Scatter(x=datos5, y=all_test_dataXG2,
                mode='lines', line=dict(width=2, color='#145DA0'), name="Real power generation", stackgaps='infer zero'), row=1, col=1)
fig5.add_trace(go.Scatter(x=datos5, y=all_predictionsXG2,
                mode='lines', line=dict(width=2, color='#EC7C30'), name="Predicted power generation", stackgaps='infer zero'), row=1, col=1)
fig5.update_layout(title='',
                  paper_bgcolor='rgba(0,0,0,0)',
                  plot_bgcolor='rgba(0,0,0,0)',
                  width=1200,height=600,
                  yaxis=dict(color="black"),
                  xaxis=dict(color="black"),
                  font=dict(family="Fira Sans, Condensed", color='black'),
                  legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=23, font_color='black'),
                  showlegend=True)
fig5.update_xaxes(showline=True, linewidth=1, linecolor='black', gridcolor='lightgray', mirror=False, title_text='<b>Time (hour)</b>', titlefont_size=23, tickfont_size=23)
fig5.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='black', mirror=False, title_text='<b>Generation (kWh)</b>', titlefont_size=23, tickfont_size=23)
fig5.show()

"""## Performance Comparison

### Graph
"""

datos3=np.array(range(0, 4551))

fig2 = go.Figure()
fig2 = make_subplots(rows=1, cols=1)
fig2.add_trace(go.Scatter(x=datos3, y=pred_LSTM_V[0:91,0],
                mode='lines', line=dict(width=2, color='#EC7C30'), name="LSTM", stackgaps='infer zero'), row=1, col=1)
fig2.add_trace(go.Scatter(x=datos3, y=all_predictionsXG2[0:91],
                mode='lines', line=dict(width=2, color='#BC1823'), name="XGBoost", stackgaps='infer zero'), row=1, col=1)
fig2.add_trace(go.Scatter(x=datos3, y=all_predictions2[0:91],
                mode='lines', line=dict(width=2, color='#303F9F'), name="SARIMA", stackgaps='infer zero'), row=1, col=1)
fig2.update_layout(title='',
                  paper_bgcolor='rgba(0,0,0,0)',
                  plot_bgcolor='rgba(0,0,0,0)',
                  width=1200,height=450,
                  yaxis=dict(color="#560216"),
                  xaxis=dict(color="#560216"),
                  font=dict(family="Fira Sans, Condensed", color='#560216'),
                  legend=dict(orientation="h",yanchor="bottom",y=1.02,xanchor="right",x=1, font_size=25, font_color='#560216'),
                  showlegend=True)
fig2.update_xaxes(showline=True, linewidth=1, linecolor='#560216', gridcolor='lightgray', mirror=False, title_text='<b>Tiempo (hora)</b>', titlefont_size=25, tickfont_size=25)
fig2.update_yaxes(showline=True, linewidth=1, gridcolor='lightgray', linecolor='#560216', mirror=False, title_text='<b>Generacion (kWh)</b>', titlefont_size=25, tickfont_size=25)
fig2.show()

model1 = [mseS, maeS, p_maeS, rmseS, p_rmseS, r2S]
model2 = [mse2L, mae2L, p_mae2L, rmse2L, p_rmse2L, r22L]
model3 = [mseX, maeX, p_maeX, rmseX, p_rmseX, r2X]

# Creamos un diccionario con los resultados de los modelos
models_results = {'SARIMA': model1, 'LSTM': model2, 'XGBoost': model3}

# Creamos un DataFrame a partir del diccionario de resultados
model_result_table = pd.DataFrame(models_results, index=['MSE', 'MAE', 'P MAE', 'RMSE', 'P RMSE', 'R2'])

# Imprimimos la tabla de resultados
print(model_result_table)

"""# References links
https://docs.python.org/3/library/datetime.html#

https://relopezbriega.github.io/blog/2016/09/26/series-de-tiempo-con-python/

https://repositorio.cepal.org/bitstream/handle/11362/4755/1/S0700590_es.pdf

https://pythonguia.com/python-pandas-reemplaza-valores-multiples-15-ejemplos/

https://support.minitab.com/es-mx/minitab/21/help-and-how-to/statistical-modeling/time-series/how-to/augmented-dickey-fuller-test/methods-and-formulas/methods-and-formulas/

https://support.numxl.com/hc/es/articles/215571923-ADFTest-Prueba-estacionaria-de-Dickey-Fuller-Aumentada#:~:text=Devuelve%20el%20valor%20%2D%20p%20%2D%20de,muestra%20de%20series%20de%20tiempo.

https://nataliaprins.github.io/cursos/Caracterizaci%C3%B3n%20de%20las%20series%20de%20tiempo/index.html

https://unipython.com/analisis-de-series-temporales-con-la-libreria-pandas/

https://www.codigopiton.com/como-hacer-un-histograma-en-python/#:~:text=Para%20hacer%20un%20histograma%20en,%2C%20Bokeh%2C%20Altair%20o%20Plotly.


"""